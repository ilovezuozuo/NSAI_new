# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from mir_msgs/RobotStatus.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import genpy
import mir_msgs.msg
import std_msgs.msg

class RobotStatus(genpy.Message):
  _md5sum = "7b840ddb96dfd7ada160f7cf87874a66"
  _type = "mir_msgs/RobotStatus"
  _has_header = True  # flag to mark the presence of a Header object
  _full_text = """Header header
float32 battery_percentage
int32 battery_time_remaining
float32 battery_voltage
float32 distance_to_next_target
Error[] errors
string footprint
HookStatus hook_status
HookData hook_data
string map_id
bool unloaded_map_changes
int32 mission_queue_id
string mission_text
int32 mode_id
string mode_text
float64 moved
Pose2D position
string robot_name
string session_id
string software_version
uint8 state_id
string state_text
int32 uptime
Twist2D velocity
mir_msgs/UserPrompt user_prompt
bool safety_system_muted
bool joystick_low_speed_mode_enabled
string joystick_web_session_id
string mode_key_state

================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id

================================================================================
MSG: mir_msgs/Error
# Definition of offsets indicating what type an error is
int32 HARDWARE_ERROR = 0
int32 CPU_LOAD_ERROR = 100
int32 MEMORY_ERROR = 200
int32 ETHERNET_ERROR = 300
int32 HDD_ERROR = 400
int32 BATTERY_ERROR = 500
int32 IMU_ERROR = 600
int32 MOTOR_ERROR = 700
int32 LASER_ERROR = 800
int32 CAMERA_ERROR = 900
int32 SAFETY_SYSTEM_ERROR = 1000
int32 POWERBOARD_ERROR = 2000
int32 POWERSUPPLY_ERROR = 2100
int32 CANBUS_ERROR = 2200
int32 HOOK_ERROR = 5000
int32 HOOK_CAMERA_ERROR = 5100
int32 HOOK_ACTUATOR_ERROR = 5200
int32 HOOK_BRAKE_ERROR = 5300
int32 HOOK_ENCODER_ERROR = 5400
int32 MISSING_ERROR = 9000
int32 SOFTWARE_ERROR = 10000
int32 MISSION_ERROR = 10100
int32 LOCALIZATION_ERROR = 10200
int32 MAPPING_ERROR = 10300
int32 ODOM_FUSION_ERROR = 10400
int32 EVACUATION_ERROR = 12000


time timestamp		# Timestamp for when the error occurred
int32 code 			# Error code
string description 	# Error description
string module		# Module in which the error occurred
bool nolog          # Do not trigger an error log if set to true

================================================================================
MSG: mir_msgs/HookStatus
bool available
float32 length
float32 height
float32 angle
bool braked

bool trolley_attached
Trolley trolley

================================================================================
MSG: mir_msgs/Trolley
int32 id
float32 length
float32 width
float32 height
float32 offset_locked_wheels

================================================================================
MSG: mir_msgs/HookData
AngleMeasurment angle
float64 height
float64 length
uint8 brake_state
uint8 gripper_state
uint8 height_state

================================================================================
MSG: mir_msgs/AngleMeasurment
float64 angle #radians
time timestamp

================================================================================
MSG: mir_msgs/Pose2D
float32 x
float32 y
float32 orientation

================================================================================
MSG: mir_msgs/Twist2D
float32 linear
float32 angular

================================================================================
MSG: mir_msgs/UserPrompt
bool has_request
string guid
string user_group
string question
string[] options
duration timeout
"""
  __slots__ = ['header','battery_percentage','battery_time_remaining','battery_voltage','distance_to_next_target','errors','footprint','hook_status','hook_data','map_id','unloaded_map_changes','mission_queue_id','mission_text','mode_id','mode_text','moved','position','robot_name','session_id','software_version','state_id','state_text','uptime','velocity','user_prompt','safety_system_muted','joystick_low_speed_mode_enabled','joystick_web_session_id','mode_key_state']
  _slot_types = ['std_msgs/Header','float32','int32','float32','float32','mir_msgs/Error[]','string','mir_msgs/HookStatus','mir_msgs/HookData','string','bool','int32','string','int32','string','float64','mir_msgs/Pose2D','string','string','string','uint8','string','int32','mir_msgs/Twist2D','mir_msgs/UserPrompt','bool','bool','string','string']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,battery_percentage,battery_time_remaining,battery_voltage,distance_to_next_target,errors,footprint,hook_status,hook_data,map_id,unloaded_map_changes,mission_queue_id,mission_text,mode_id,mode_text,moved,position,robot_name,session_id,software_version,state_id,state_text,uptime,velocity,user_prompt,safety_system_muted,joystick_low_speed_mode_enabled,joystick_web_session_id,mode_key_state

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(RobotStatus, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.battery_percentage is None:
        self.battery_percentage = 0.
      if self.battery_time_remaining is None:
        self.battery_time_remaining = 0
      if self.battery_voltage is None:
        self.battery_voltage = 0.
      if self.distance_to_next_target is None:
        self.distance_to_next_target = 0.
      if self.errors is None:
        self.errors = []
      if self.footprint is None:
        self.footprint = ''
      if self.hook_status is None:
        self.hook_status = mir_msgs.msg.HookStatus()
      if self.hook_data is None:
        self.hook_data = mir_msgs.msg.HookData()
      if self.map_id is None:
        self.map_id = ''
      if self.unloaded_map_changes is None:
        self.unloaded_map_changes = False
      if self.mission_queue_id is None:
        self.mission_queue_id = 0
      if self.mission_text is None:
        self.mission_text = ''
      if self.mode_id is None:
        self.mode_id = 0
      if self.mode_text is None:
        self.mode_text = ''
      if self.moved is None:
        self.moved = 0.
      if self.position is None:
        self.position = mir_msgs.msg.Pose2D()
      if self.robot_name is None:
        self.robot_name = ''
      if self.session_id is None:
        self.session_id = ''
      if self.software_version is None:
        self.software_version = ''
      if self.state_id is None:
        self.state_id = 0
      if self.state_text is None:
        self.state_text = ''
      if self.uptime is None:
        self.uptime = 0
      if self.velocity is None:
        self.velocity = mir_msgs.msg.Twist2D()
      if self.user_prompt is None:
        self.user_prompt = mir_msgs.msg.UserPrompt()
      if self.safety_system_muted is None:
        self.safety_system_muted = False
      if self.joystick_low_speed_mode_enabled is None:
        self.joystick_low_speed_mode_enabled = False
      if self.joystick_web_session_id is None:
        self.joystick_web_session_id = ''
      if self.mode_key_state is None:
        self.mode_key_state = ''
    else:
      self.header = std_msgs.msg.Header()
      self.battery_percentage = 0.
      self.battery_time_remaining = 0
      self.battery_voltage = 0.
      self.distance_to_next_target = 0.
      self.errors = []
      self.footprint = ''
      self.hook_status = mir_msgs.msg.HookStatus()
      self.hook_data = mir_msgs.msg.HookData()
      self.map_id = ''
      self.unloaded_map_changes = False
      self.mission_queue_id = 0
      self.mission_text = ''
      self.mode_id = 0
      self.mode_text = ''
      self.moved = 0.
      self.position = mir_msgs.msg.Pose2D()
      self.robot_name = ''
      self.session_id = ''
      self.software_version = ''
      self.state_id = 0
      self.state_text = ''
      self.uptime = 0
      self.velocity = mir_msgs.msg.Twist2D()
      self.user_prompt = mir_msgs.msg.UserPrompt()
      self.safety_system_muted = False
      self.joystick_low_speed_mode_enabled = False
      self.joystick_web_session_id = ''
      self.mode_key_state = ''

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_fi2f().pack(_x.battery_percentage, _x.battery_time_remaining, _x.battery_voltage, _x.distance_to_next_target))
      length = len(self.errors)
      buff.write(_struct_I.pack(length))
      for val1 in self.errors:
        _v1 = val1.timestamp
        _x = _v1
        buff.write(_get_struct_2I().pack(_x.secs, _x.nsecs))
        _x = val1.code
        buff.write(_get_struct_i().pack(_x))
        _x = val1.description
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.module
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.nolog
        buff.write(_get_struct_B().pack(_x))
      _x = self.footprint
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_B3f2Bi4fd2I2d3B().pack(_x.hook_status.available, _x.hook_status.length, _x.hook_status.height, _x.hook_status.angle, _x.hook_status.braked, _x.hook_status.trolley_attached, _x.hook_status.trolley.id, _x.hook_status.trolley.length, _x.hook_status.trolley.width, _x.hook_status.trolley.height, _x.hook_status.trolley.offset_locked_wheels, _x.hook_data.angle.angle, _x.hook_data.angle.timestamp.secs, _x.hook_data.angle.timestamp.nsecs, _x.hook_data.height, _x.hook_data.length, _x.hook_data.brake_state, _x.hook_data.gripper_state, _x.hook_data.height_state))
      _x = self.map_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_Bi().pack(_x.unloaded_map_changes, _x.mission_queue_id))
      _x = self.mission_text
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.mode_id
      buff.write(_get_struct_i().pack(_x))
      _x = self.mode_text
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_d3f().pack(_x.moved, _x.position.x, _x.position.y, _x.position.orientation))
      _x = self.robot_name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.session_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.software_version
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.state_id
      buff.write(_get_struct_B().pack(_x))
      _x = self.state_text
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_i2fB().pack(_x.uptime, _x.velocity.linear, _x.velocity.angular, _x.user_prompt.has_request))
      _x = self.user_prompt.guid
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.user_prompt.user_group
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.user_prompt.question
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      length = len(self.user_prompt.options)
      buff.write(_struct_I.pack(length))
      for val1 in self.user_prompt.options:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      _x = self
      buff.write(_get_struct_2i2B().pack(_x.user_prompt.timeout.secs, _x.user_prompt.timeout.nsecs, _x.safety_system_muted, _x.joystick_low_speed_mode_enabled))
      _x = self.joystick_web_session_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.mode_key_state
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.errors is None:
        self.errors = None
      if self.hook_status is None:
        self.hook_status = mir_msgs.msg.HookStatus()
      if self.hook_data is None:
        self.hook_data = mir_msgs.msg.HookData()
      if self.position is None:
        self.position = mir_msgs.msg.Pose2D()
      if self.velocity is None:
        self.velocity = mir_msgs.msg.Twist2D()
      if self.user_prompt is None:
        self.user_prompt = mir_msgs.msg.UserPrompt()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.battery_percentage, _x.battery_time_remaining, _x.battery_voltage, _x.distance_to_next_target,) = _get_struct_fi2f().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.errors = []
      for i in range(0, length):
        val1 = mir_msgs.msg.Error()
        _v2 = val1.timestamp
        _x = _v2
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _get_struct_2I().unpack(str[start:end])
        start = end
        end += 4
        (val1.code,) = _get_struct_i().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.description = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.description = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.module = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.module = str[start:end]
        start = end
        end += 1
        (val1.nolog,) = _get_struct_B().unpack(str[start:end])
        val1.nolog = bool(val1.nolog)
        self.errors.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.footprint = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.footprint = str[start:end]
      _x = self
      start = end
      end += 70
      (_x.hook_status.available, _x.hook_status.length, _x.hook_status.height, _x.hook_status.angle, _x.hook_status.braked, _x.hook_status.trolley_attached, _x.hook_status.trolley.id, _x.hook_status.trolley.length, _x.hook_status.trolley.width, _x.hook_status.trolley.height, _x.hook_status.trolley.offset_locked_wheels, _x.hook_data.angle.angle, _x.hook_data.angle.timestamp.secs, _x.hook_data.angle.timestamp.nsecs, _x.hook_data.height, _x.hook_data.length, _x.hook_data.brake_state, _x.hook_data.gripper_state, _x.hook_data.height_state,) = _get_struct_B3f2Bi4fd2I2d3B().unpack(str[start:end])
      self.hook_status.available = bool(self.hook_status.available)
      self.hook_status.braked = bool(self.hook_status.braked)
      self.hook_status.trolley_attached = bool(self.hook_status.trolley_attached)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.map_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.map_id = str[start:end]
      _x = self
      start = end
      end += 5
      (_x.unloaded_map_changes, _x.mission_queue_id,) = _get_struct_Bi().unpack(str[start:end])
      self.unloaded_map_changes = bool(self.unloaded_map_changes)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.mission_text = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.mission_text = str[start:end]
      start = end
      end += 4
      (self.mode_id,) = _get_struct_i().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.mode_text = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.mode_text = str[start:end]
      _x = self
      start = end
      end += 20
      (_x.moved, _x.position.x, _x.position.y, _x.position.orientation,) = _get_struct_d3f().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.robot_name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.robot_name = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.session_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.session_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.software_version = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.software_version = str[start:end]
      start = end
      end += 1
      (self.state_id,) = _get_struct_B().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.state_text = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.state_text = str[start:end]
      _x = self
      start = end
      end += 13
      (_x.uptime, _x.velocity.linear, _x.velocity.angular, _x.user_prompt.has_request,) = _get_struct_i2fB().unpack(str[start:end])
      self.user_prompt.has_request = bool(self.user_prompt.has_request)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.user_prompt.guid = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.user_prompt.guid = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.user_prompt.user_group = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.user_prompt.user_group = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.user_prompt.question = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.user_prompt.question = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.user_prompt.options = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.user_prompt.options.append(val1)
      _x = self
      start = end
      end += 10
      (_x.user_prompt.timeout.secs, _x.user_prompt.timeout.nsecs, _x.safety_system_muted, _x.joystick_low_speed_mode_enabled,) = _get_struct_2i2B().unpack(str[start:end])
      self.safety_system_muted = bool(self.safety_system_muted)
      self.joystick_low_speed_mode_enabled = bool(self.joystick_low_speed_mode_enabled)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.joystick_web_session_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.joystick_web_session_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.mode_key_state = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.mode_key_state = str[start:end]
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_fi2f().pack(_x.battery_percentage, _x.battery_time_remaining, _x.battery_voltage, _x.distance_to_next_target))
      length = len(self.errors)
      buff.write(_struct_I.pack(length))
      for val1 in self.errors:
        _v3 = val1.timestamp
        _x = _v3
        buff.write(_get_struct_2I().pack(_x.secs, _x.nsecs))
        _x = val1.code
        buff.write(_get_struct_i().pack(_x))
        _x = val1.description
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.module
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.nolog
        buff.write(_get_struct_B().pack(_x))
      _x = self.footprint
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_B3f2Bi4fd2I2d3B().pack(_x.hook_status.available, _x.hook_status.length, _x.hook_status.height, _x.hook_status.angle, _x.hook_status.braked, _x.hook_status.trolley_attached, _x.hook_status.trolley.id, _x.hook_status.trolley.length, _x.hook_status.trolley.width, _x.hook_status.trolley.height, _x.hook_status.trolley.offset_locked_wheels, _x.hook_data.angle.angle, _x.hook_data.angle.timestamp.secs, _x.hook_data.angle.timestamp.nsecs, _x.hook_data.height, _x.hook_data.length, _x.hook_data.brake_state, _x.hook_data.gripper_state, _x.hook_data.height_state))
      _x = self.map_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_Bi().pack(_x.unloaded_map_changes, _x.mission_queue_id))
      _x = self.mission_text
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.mode_id
      buff.write(_get_struct_i().pack(_x))
      _x = self.mode_text
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_d3f().pack(_x.moved, _x.position.x, _x.position.y, _x.position.orientation))
      _x = self.robot_name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.session_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.software_version
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.state_id
      buff.write(_get_struct_B().pack(_x))
      _x = self.state_text
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_i2fB().pack(_x.uptime, _x.velocity.linear, _x.velocity.angular, _x.user_prompt.has_request))
      _x = self.user_prompt.guid
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.user_prompt.user_group
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.user_prompt.question
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      length = len(self.user_prompt.options)
      buff.write(_struct_I.pack(length))
      for val1 in self.user_prompt.options:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      _x = self
      buff.write(_get_struct_2i2B().pack(_x.user_prompt.timeout.secs, _x.user_prompt.timeout.nsecs, _x.safety_system_muted, _x.joystick_low_speed_mode_enabled))
      _x = self.joystick_web_session_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.mode_key_state
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.errors is None:
        self.errors = None
      if self.hook_status is None:
        self.hook_status = mir_msgs.msg.HookStatus()
      if self.hook_data is None:
        self.hook_data = mir_msgs.msg.HookData()
      if self.position is None:
        self.position = mir_msgs.msg.Pose2D()
      if self.velocity is None:
        self.velocity = mir_msgs.msg.Twist2D()
      if self.user_prompt is None:
        self.user_prompt = mir_msgs.msg.UserPrompt()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.battery_percentage, _x.battery_time_remaining, _x.battery_voltage, _x.distance_to_next_target,) = _get_struct_fi2f().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.errors = []
      for i in range(0, length):
        val1 = mir_msgs.msg.Error()
        _v4 = val1.timestamp
        _x = _v4
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _get_struct_2I().unpack(str[start:end])
        start = end
        end += 4
        (val1.code,) = _get_struct_i().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.description = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.description = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.module = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.module = str[start:end]
        start = end
        end += 1
        (val1.nolog,) = _get_struct_B().unpack(str[start:end])
        val1.nolog = bool(val1.nolog)
        self.errors.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.footprint = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.footprint = str[start:end]
      _x = self
      start = end
      end += 70
      (_x.hook_status.available, _x.hook_status.length, _x.hook_status.height, _x.hook_status.angle, _x.hook_status.braked, _x.hook_status.trolley_attached, _x.hook_status.trolley.id, _x.hook_status.trolley.length, _x.hook_status.trolley.width, _x.hook_status.trolley.height, _x.hook_status.trolley.offset_locked_wheels, _x.hook_data.angle.angle, _x.hook_data.angle.timestamp.secs, _x.hook_data.angle.timestamp.nsecs, _x.hook_data.height, _x.hook_data.length, _x.hook_data.brake_state, _x.hook_data.gripper_state, _x.hook_data.height_state,) = _get_struct_B3f2Bi4fd2I2d3B().unpack(str[start:end])
      self.hook_status.available = bool(self.hook_status.available)
      self.hook_status.braked = bool(self.hook_status.braked)
      self.hook_status.trolley_attached = bool(self.hook_status.trolley_attached)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.map_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.map_id = str[start:end]
      _x = self
      start = end
      end += 5
      (_x.unloaded_map_changes, _x.mission_queue_id,) = _get_struct_Bi().unpack(str[start:end])
      self.unloaded_map_changes = bool(self.unloaded_map_changes)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.mission_text = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.mission_text = str[start:end]
      start = end
      end += 4
      (self.mode_id,) = _get_struct_i().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.mode_text = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.mode_text = str[start:end]
      _x = self
      start = end
      end += 20
      (_x.moved, _x.position.x, _x.position.y, _x.position.orientation,) = _get_struct_d3f().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.robot_name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.robot_name = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.session_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.session_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.software_version = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.software_version = str[start:end]
      start = end
      end += 1
      (self.state_id,) = _get_struct_B().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.state_text = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.state_text = str[start:end]
      _x = self
      start = end
      end += 13
      (_x.uptime, _x.velocity.linear, _x.velocity.angular, _x.user_prompt.has_request,) = _get_struct_i2fB().unpack(str[start:end])
      self.user_prompt.has_request = bool(self.user_prompt.has_request)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.user_prompt.guid = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.user_prompt.guid = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.user_prompt.user_group = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.user_prompt.user_group = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.user_prompt.question = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.user_prompt.question = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.user_prompt.options = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.user_prompt.options.append(val1)
      _x = self
      start = end
      end += 10
      (_x.user_prompt.timeout.secs, _x.user_prompt.timeout.nsecs, _x.safety_system_muted, _x.joystick_low_speed_mode_enabled,) = _get_struct_2i2B().unpack(str[start:end])
      self.safety_system_muted = bool(self.safety_system_muted)
      self.joystick_low_speed_mode_enabled = bool(self.joystick_low_speed_mode_enabled)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.joystick_web_session_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.joystick_web_session_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.mode_key_state = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.mode_key_state = str[start:end]
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_2I = None
def _get_struct_2I():
    global _struct_2I
    if _struct_2I is None:
        _struct_2I = struct.Struct("<2I")
    return _struct_2I
_struct_2i2B = None
def _get_struct_2i2B():
    global _struct_2i2B
    if _struct_2i2B is None:
        _struct_2i2B = struct.Struct("<2i2B")
    return _struct_2i2B
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
_struct_B = None
def _get_struct_B():
    global _struct_B
    if _struct_B is None:
        _struct_B = struct.Struct("<B")
    return _struct_B
_struct_B3f2Bi4fd2I2d3B = None
def _get_struct_B3f2Bi4fd2I2d3B():
    global _struct_B3f2Bi4fd2I2d3B
    if _struct_B3f2Bi4fd2I2d3B is None:
        _struct_B3f2Bi4fd2I2d3B = struct.Struct("<B3f2Bi4fd2I2d3B")
    return _struct_B3f2Bi4fd2I2d3B
_struct_Bi = None
def _get_struct_Bi():
    global _struct_Bi
    if _struct_Bi is None:
        _struct_Bi = struct.Struct("<Bi")
    return _struct_Bi
_struct_d3f = None
def _get_struct_d3f():
    global _struct_d3f
    if _struct_d3f is None:
        _struct_d3f = struct.Struct("<d3f")
    return _struct_d3f
_struct_fi2f = None
def _get_struct_fi2f():
    global _struct_fi2f
    if _struct_fi2f is None:
        _struct_fi2f = struct.Struct("<fi2f")
    return _struct_fi2f
_struct_i = None
def _get_struct_i():
    global _struct_i
    if _struct_i is None:
        _struct_i = struct.Struct("<i")
    return _struct_i
_struct_i2fB = None
def _get_struct_i2fB():
    global _struct_i2fB
    if _struct_i2fB is None:
        _struct_i2fB = struct.Struct("<i2fB")
    return _struct_i2fB
