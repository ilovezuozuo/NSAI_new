// Generated by gencpp from file mir_msgs/BMSData.msg
// DO NOT EDIT!


#ifndef MIR_MSGS_MESSAGE_BMSDATA_H
#define MIR_MSGS_MESSAGE_BMSDATA_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace mir_msgs
{
template <class ContainerAllocator>
struct BMSData_
{
  typedef BMSData_<ContainerAllocator> Type;

  BMSData_()
    : pack_voltage(0.0)
    , charge_current(0.0)
    , discharge_current(0.0)
    , state_of_charge(0.0)
    , remaining_time_to_full_charge(0.0)
    , remaining_capacity(0)
    , state_of_health(0)
    , status_flags(0)
    , temperature(0)
    , cell_voltage()
    , cell_voltage_diff(0)
    , WST_serial()
    , bmz_flag(0)
    , battery_type(0)
    , full_voltage(0.0)
    , full_capacity(0)
    , temperature2(0)
    , temperature_pcb(0)
    , cycle_count(0)
    , dsg_overcurrent_counter(0)
    , chg_overcurrent_counter(0)
    , hw_major(0)
    , hw_minor(0)
    , fw_major(0)
    , fw_minor(0)
    , fw_patch(0)
    , fw_parameters_ok(0)
    , rec_fw_major(0)
    , rec_fw_minor(0)
    , rec_fw_patch(0)
    , bl_major(0)
    , bl_minor(0)
    , status_enabled(0)
    , status_current_limitation(0)
    , status_switch_off_warn1(0)
    , status_switch_off_warn2(0)
    , status_fully_discharged(0)
    , status_nearly_discharged(0)
    , status_chargefet_on(0)
    , status_dischargefet_on(0)
    , status_discharging(0)
    , status_fully_charged(0)
    , status_charging(0)
    , status_temp_charging_err(0)
    , status_cell_over_voltage(0)
    , status_cell_under_voltage(0)
    , status_charge_over_current(0)
    , status_shortcircuit(0)
    , status_discharge_over_current(0)
    , status_chargefet_voltage(0.0)
    , status_dischargefet_voltage(0.0)
    , status_temp_discharging_err(0)
    , status_charger_detected(0)
    , mnfct_bms_revision(0)
    , mnfct_asn_revision(0)
    , mnfct_year(0)
    , mnfct_week(0)
    , mnfct_model(0)
    , mnfct_serial(0)
    , afe_i2c_error_count(0)
    , app_error_count(0)
    , fet_disable_state(0)
    , last_battery_msg_time(0.0)
    , SBS_battery_status(0)
    , SBS_battery_status_raw(0)
    , SBS_serial_1()
    , SBS_serial_2()
    , SBS_arti_nr_1(0)
    , SBS_arti_nr_2(0)
    , SBS_arti_nr_3(0)
    , SBS_curr_flow_passive_state(0)
    , CHG_OC1_Count(0)
    , CHG_OC2_Count(0)
    , DSG_OC1_Count(0)
    , DSG_OC2_Count(0)
    , DSG_OC3_Count(0)
    , AFE_OC1_Count(0)
    , AFE_OC2_Count(0)
    , CHG_LatchClear_Count(0)
    , DSG_LatchClear_Count(0)
    , chg_oc_warning(0)
    , dsg_oc_warning(0)  {
    }
  BMSData_(const ContainerAllocator& _alloc)
    : pack_voltage(0.0)
    , charge_current(0.0)
    , discharge_current(0.0)
    , state_of_charge(0.0)
    , remaining_time_to_full_charge(0.0)
    , remaining_capacity(0)
    , state_of_health(0)
    , status_flags(0)
    , temperature(0)
    , cell_voltage(_alloc)
    , cell_voltage_diff(0)
    , WST_serial(_alloc)
    , bmz_flag(0)
    , battery_type(0)
    , full_voltage(0.0)
    , full_capacity(0)
    , temperature2(0)
    , temperature_pcb(0)
    , cycle_count(0)
    , dsg_overcurrent_counter(0)
    , chg_overcurrent_counter(0)
    , hw_major(0)
    , hw_minor(0)
    , fw_major(0)
    , fw_minor(0)
    , fw_patch(0)
    , fw_parameters_ok(0)
    , rec_fw_major(0)
    , rec_fw_minor(0)
    , rec_fw_patch(0)
    , bl_major(0)
    , bl_minor(0)
    , status_enabled(0)
    , status_current_limitation(0)
    , status_switch_off_warn1(0)
    , status_switch_off_warn2(0)
    , status_fully_discharged(0)
    , status_nearly_discharged(0)
    , status_chargefet_on(0)
    , status_dischargefet_on(0)
    , status_discharging(0)
    , status_fully_charged(0)
    , status_charging(0)
    , status_temp_charging_err(0)
    , status_cell_over_voltage(0)
    , status_cell_under_voltage(0)
    , status_charge_over_current(0)
    , status_shortcircuit(0)
    , status_discharge_over_current(0)
    , status_chargefet_voltage(0.0)
    , status_dischargefet_voltage(0.0)
    , status_temp_discharging_err(0)
    , status_charger_detected(0)
    , mnfct_bms_revision(0)
    , mnfct_asn_revision(0)
    , mnfct_year(0)
    , mnfct_week(0)
    , mnfct_model(0)
    , mnfct_serial(0)
    , afe_i2c_error_count(0)
    , app_error_count(0)
    , fet_disable_state(0)
    , last_battery_msg_time(0.0)
    , SBS_battery_status(0)
    , SBS_battery_status_raw(0)
    , SBS_serial_1(_alloc)
    , SBS_serial_2(_alloc)
    , SBS_arti_nr_1(0)
    , SBS_arti_nr_2(0)
    , SBS_arti_nr_3(0)
    , SBS_curr_flow_passive_state(0)
    , CHG_OC1_Count(0)
    , CHG_OC2_Count(0)
    , DSG_OC1_Count(0)
    , DSG_OC2_Count(0)
    , DSG_OC3_Count(0)
    , AFE_OC1_Count(0)
    , AFE_OC2_Count(0)
    , CHG_LatchClear_Count(0)
    , DSG_LatchClear_Count(0)
    , chg_oc_warning(0)
    , dsg_oc_warning(0)  {
  (void)_alloc;
    }



   typedef double _pack_voltage_type;
  _pack_voltage_type pack_voltage;

   typedef double _charge_current_type;
  _charge_current_type charge_current;

   typedef double _discharge_current_type;
  _discharge_current_type discharge_current;

   typedef double _state_of_charge_type;
  _state_of_charge_type state_of_charge;

   typedef double _remaining_time_to_full_charge_type;
  _remaining_time_to_full_charge_type remaining_time_to_full_charge;

   typedef int32_t _remaining_capacity_type;
  _remaining_capacity_type remaining_capacity;

   typedef int32_t _state_of_health_type;
  _state_of_health_type state_of_health;

   typedef int32_t _status_flags_type;
  _status_flags_type status_flags;

   typedef int32_t _temperature_type;
  _temperature_type temperature;

   typedef std::vector<uint32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<uint32_t>> _cell_voltage_type;
  _cell_voltage_type cell_voltage;

   typedef uint32_t _cell_voltage_diff_type;
  _cell_voltage_diff_type cell_voltage_diff;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _WST_serial_type;
  _WST_serial_type WST_serial;

   typedef uint32_t _bmz_flag_type;
  _bmz_flag_type bmz_flag;

   typedef uint32_t _battery_type_type;
  _battery_type_type battery_type;

   typedef double _full_voltage_type;
  _full_voltage_type full_voltage;

   typedef int32_t _full_capacity_type;
  _full_capacity_type full_capacity;

   typedef int32_t _temperature2_type;
  _temperature2_type temperature2;

   typedef int32_t _temperature_pcb_type;
  _temperature_pcb_type temperature_pcb;

   typedef int32_t _cycle_count_type;
  _cycle_count_type cycle_count;

   typedef int32_t _dsg_overcurrent_counter_type;
  _dsg_overcurrent_counter_type dsg_overcurrent_counter;

   typedef int32_t _chg_overcurrent_counter_type;
  _chg_overcurrent_counter_type chg_overcurrent_counter;

   typedef int32_t _hw_major_type;
  _hw_major_type hw_major;

   typedef int32_t _hw_minor_type;
  _hw_minor_type hw_minor;

   typedef int32_t _fw_major_type;
  _fw_major_type fw_major;

   typedef int32_t _fw_minor_type;
  _fw_minor_type fw_minor;

   typedef int32_t _fw_patch_type;
  _fw_patch_type fw_patch;

   typedef int32_t _fw_parameters_ok_type;
  _fw_parameters_ok_type fw_parameters_ok;

   typedef int32_t _rec_fw_major_type;
  _rec_fw_major_type rec_fw_major;

   typedef int32_t _rec_fw_minor_type;
  _rec_fw_minor_type rec_fw_minor;

   typedef int32_t _rec_fw_patch_type;
  _rec_fw_patch_type rec_fw_patch;

   typedef int32_t _bl_major_type;
  _bl_major_type bl_major;

   typedef int32_t _bl_minor_type;
  _bl_minor_type bl_minor;

   typedef uint32_t _status_enabled_type;
  _status_enabled_type status_enabled;

   typedef uint32_t _status_current_limitation_type;
  _status_current_limitation_type status_current_limitation;

   typedef uint32_t _status_switch_off_warn1_type;
  _status_switch_off_warn1_type status_switch_off_warn1;

   typedef uint32_t _status_switch_off_warn2_type;
  _status_switch_off_warn2_type status_switch_off_warn2;

   typedef uint32_t _status_fully_discharged_type;
  _status_fully_discharged_type status_fully_discharged;

   typedef uint32_t _status_nearly_discharged_type;
  _status_nearly_discharged_type status_nearly_discharged;

   typedef uint32_t _status_chargefet_on_type;
  _status_chargefet_on_type status_chargefet_on;

   typedef uint32_t _status_dischargefet_on_type;
  _status_dischargefet_on_type status_dischargefet_on;

   typedef uint32_t _status_discharging_type;
  _status_discharging_type status_discharging;

   typedef uint32_t _status_fully_charged_type;
  _status_fully_charged_type status_fully_charged;

   typedef uint32_t _status_charging_type;
  _status_charging_type status_charging;

   typedef uint32_t _status_temp_charging_err_type;
  _status_temp_charging_err_type status_temp_charging_err;

   typedef uint32_t _status_cell_over_voltage_type;
  _status_cell_over_voltage_type status_cell_over_voltage;

   typedef uint32_t _status_cell_under_voltage_type;
  _status_cell_under_voltage_type status_cell_under_voltage;

   typedef uint32_t _status_charge_over_current_type;
  _status_charge_over_current_type status_charge_over_current;

   typedef uint32_t _status_shortcircuit_type;
  _status_shortcircuit_type status_shortcircuit;

   typedef uint32_t _status_discharge_over_current_type;
  _status_discharge_over_current_type status_discharge_over_current;

   typedef double _status_chargefet_voltage_type;
  _status_chargefet_voltage_type status_chargefet_voltage;

   typedef double _status_dischargefet_voltage_type;
  _status_dischargefet_voltage_type status_dischargefet_voltage;

   typedef uint32_t _status_temp_discharging_err_type;
  _status_temp_discharging_err_type status_temp_discharging_err;

   typedef uint32_t _status_charger_detected_type;
  _status_charger_detected_type status_charger_detected;

   typedef uint32_t _mnfct_bms_revision_type;
  _mnfct_bms_revision_type mnfct_bms_revision;

   typedef uint32_t _mnfct_asn_revision_type;
  _mnfct_asn_revision_type mnfct_asn_revision;

   typedef uint32_t _mnfct_year_type;
  _mnfct_year_type mnfct_year;

   typedef uint32_t _mnfct_week_type;
  _mnfct_week_type mnfct_week;

   typedef uint32_t _mnfct_model_type;
  _mnfct_model_type mnfct_model;

   typedef uint32_t _mnfct_serial_type;
  _mnfct_serial_type mnfct_serial;

   typedef uint32_t _afe_i2c_error_count_type;
  _afe_i2c_error_count_type afe_i2c_error_count;

   typedef uint32_t _app_error_count_type;
  _app_error_count_type app_error_count;

   typedef uint32_t _fet_disable_state_type;
  _fet_disable_state_type fet_disable_state;

   typedef double _last_battery_msg_time_type;
  _last_battery_msg_time_type last_battery_msg_time;

   typedef uint32_t _SBS_battery_status_type;
  _SBS_battery_status_type SBS_battery_status;

   typedef uint32_t _SBS_battery_status_raw_type;
  _SBS_battery_status_raw_type SBS_battery_status_raw;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _SBS_serial_1_type;
  _SBS_serial_1_type SBS_serial_1;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _SBS_serial_2_type;
  _SBS_serial_2_type SBS_serial_2;

   typedef uint32_t _SBS_arti_nr_1_type;
  _SBS_arti_nr_1_type SBS_arti_nr_1;

   typedef uint32_t _SBS_arti_nr_2_type;
  _SBS_arti_nr_2_type SBS_arti_nr_2;

   typedef uint32_t _SBS_arti_nr_3_type;
  _SBS_arti_nr_3_type SBS_arti_nr_3;

   typedef uint32_t _SBS_curr_flow_passive_state_type;
  _SBS_curr_flow_passive_state_type SBS_curr_flow_passive_state;

   typedef uint8_t _CHG_OC1_Count_type;
  _CHG_OC1_Count_type CHG_OC1_Count;

   typedef uint8_t _CHG_OC2_Count_type;
  _CHG_OC2_Count_type CHG_OC2_Count;

   typedef uint8_t _DSG_OC1_Count_type;
  _DSG_OC1_Count_type DSG_OC1_Count;

   typedef uint8_t _DSG_OC2_Count_type;
  _DSG_OC2_Count_type DSG_OC2_Count;

   typedef uint8_t _DSG_OC3_Count_type;
  _DSG_OC3_Count_type DSG_OC3_Count;

   typedef uint8_t _AFE_OC1_Count_type;
  _AFE_OC1_Count_type AFE_OC1_Count;

   typedef uint8_t _AFE_OC2_Count_type;
  _AFE_OC2_Count_type AFE_OC2_Count;

   typedef uint8_t _CHG_LatchClear_Count_type;
  _CHG_LatchClear_Count_type CHG_LatchClear_Count;

   typedef uint8_t _DSG_LatchClear_Count_type;
  _DSG_LatchClear_Count_type DSG_LatchClear_Count;

   typedef uint8_t _chg_oc_warning_type;
  _chg_oc_warning_type chg_oc_warning;

   typedef uint8_t _dsg_oc_warning_type;
  _dsg_oc_warning_type dsg_oc_warning;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(DISCHARGING)
  #undef DISCHARGING
#endif
#if defined(_WIN32) && defined(CHARGING)
  #undef CHARGING
#endif
#if defined(_WIN32) && defined(OV)
  #undef OV
#endif
#if defined(_WIN32) && defined(UV)
  #undef UV
#endif
#if defined(_WIN32) && defined(COC)
  #undef COC
#endif
#if defined(_WIN32) && defined(DOC)
  #undef DOC
#endif
#if defined(_WIN32) && defined(DOT)
  #undef DOT
#endif
#if defined(_WIN32) && defined(DUT)
  #undef DUT
#endif
#if defined(_WIN32) && defined(SC)
  #undef SC
#endif
#if defined(_WIN32) && defined(COT)
  #undef COT
#endif
#if defined(_WIN32) && defined(CUT)
  #undef CUT
#endif
#if defined(_WIN32) && defined(FW_STATUS_MSK)
  #undef FW_STATUS_MSK
#endif
#if defined(_WIN32) && defined(FW_STATUS_SHIFT)
  #undef FW_STATUS_SHIFT
#endif
#if defined(_WIN32) && defined(FW_UPD_OK)
  #undef FW_UPD_OK
#endif
#if defined(_WIN32) && defined(FW_UPD_RUNNING)
  #undef FW_UPD_RUNNING
#endif
#if defined(_WIN32) && defined(FW_UPD_FAILED_BOOT)
  #undef FW_UPD_FAILED_BOOT
#endif
#if defined(_WIN32) && defined(FW_UPD_FAILED_APP)
  #undef FW_UPD_FAILED_APP
#endif
#if defined(_WIN32) && defined(FW_UPD_FAILED_PARAM)
  #undef FW_UPD_FAILED_PARAM
#endif
#if defined(_WIN32) && defined(FW_STATUS_LOW_BATT)
  #undef FW_STATUS_LOW_BATT
#endif
#if defined(_WIN32) && defined(FW_STATUS_FILE_CORRUPTED)
  #undef FW_STATUS_FILE_CORRUPTED
#endif
#if defined(_WIN32) && defined(FW_STATUS_CURRENT_TO_HIGH)
  #undef FW_STATUS_CURRENT_TO_HIGH
#endif
#if defined(_WIN32) && defined(FW_STATUS_NO_CAN)
  #undef FW_STATUS_NO_CAN
#endif
#if defined(_WIN32) && defined(FW_BATTERY_IMBALANCE_HIGH)
  #undef FW_BATTERY_IMBALANCE_HIGH
#endif
#if defined(_WIN32) && defined(BATT_TYPE_UNKNOWN)
  #undef BATT_TYPE_UNKNOWN
#endif
#if defined(_WIN32) && defined(BATT_TYPE_BMZ)
  #undef BATT_TYPE_BMZ
#endif
#if defined(_WIN32) && defined(BATT_TYPE_WST)
  #undef BATT_TYPE_WST
#endif
#if defined(_WIN32) && defined(BATT_TYPE_SBS)
  #undef BATT_TYPE_SBS
#endif
#if defined(_WIN32) && defined(BATT_TYPE_SBS_SLIDE)
  #undef BATT_TYPE_SBS_SLIDE
#endif
#if defined(_WIN32) && defined(BATT_TYPE_NO_BMS)
  #undef BATT_TYPE_NO_BMS
#endif
#if defined(_WIN32) && defined(SBS_InitState1)
  #undef SBS_InitState1
#endif
#if defined(_WIN32) && defined(SBS_InitState2)
  #undef SBS_InitState2
#endif
#if defined(_WIN32) && defined(SBS_InitState3)
  #undef SBS_InitState3
#endif
#if defined(_WIN32) && defined(SBS_InitState4)
  #undef SBS_InitState4
#endif
#if defined(_WIN32) && defined(SBS_Idle)
  #undef SBS_Idle
#endif
#if defined(_WIN32) && defined(SBS_Discharge)
  #undef SBS_Discharge
#endif
#if defined(_WIN32) && defined(SBS_Charge)
  #undef SBS_Charge
#endif
#if defined(_WIN32) && defined(SBS_Fault)
  #undef SBS_Fault
#endif
#if defined(_WIN32) && defined(SBS_CriticalError)
  #undef SBS_CriticalError
#endif
#if defined(_WIN32) && defined(SBS_PrepareDeepsleep)
  #undef SBS_PrepareDeepsleep
#endif
#if defined(_WIN32) && defined(SBS_Deepsleep)
  #undef SBS_Deepsleep
#endif

  enum {
    DISCHARGING = 1,
    CHARGING = 2,
    OV = 4,
    UV = 8,
    COC = 16,
    DOC = 32,
    DOT = 64,
    DUT = 128,
    SC = 512,
    COT = 1024,
    CUT = 2048,
    FW_STATUS_MSK = 2031616,
    FW_STATUS_SHIFT = 16,
    FW_UPD_OK = 0,
    FW_UPD_RUNNING = 1,
    FW_UPD_FAILED_BOOT = 2,
    FW_UPD_FAILED_APP = 3,
    FW_UPD_FAILED_PARAM = 4,
    FW_STATUS_LOW_BATT = 5,
    FW_STATUS_FILE_CORRUPTED = 6,
    FW_STATUS_CURRENT_TO_HIGH = 7,
    FW_STATUS_NO_CAN = 8,
    FW_BATTERY_IMBALANCE_HIGH = 9,
    BATT_TYPE_UNKNOWN = 0u,
    BATT_TYPE_BMZ = 1u,
    BATT_TYPE_WST = 2u,
    BATT_TYPE_SBS = 3u,
    BATT_TYPE_SBS_SLIDE = 4u,
    BATT_TYPE_NO_BMS = 255u,
    SBS_InitState1 = 1u,
    SBS_InitState2 = 2u,
    SBS_InitState3 = 3u,
    SBS_InitState4 = 4u,
    SBS_Idle = 5u,
    SBS_Discharge = 6u,
    SBS_Charge = 7u,
    SBS_Fault = 10u,
    SBS_CriticalError = 11u,
    SBS_PrepareDeepsleep = 99u,
    SBS_Deepsleep = 100u,
  };


  typedef boost::shared_ptr< ::mir_msgs::BMSData_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::mir_msgs::BMSData_<ContainerAllocator> const> ConstPtr;

}; // struct BMSData_

typedef ::mir_msgs::BMSData_<std::allocator<void> > BMSData;

typedef boost::shared_ptr< ::mir_msgs::BMSData > BMSDataPtr;
typedef boost::shared_ptr< ::mir_msgs::BMSData const> BMSDataConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::mir_msgs::BMSData_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::mir_msgs::BMSData_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::mir_msgs::BMSData_<ContainerAllocator1> & lhs, const ::mir_msgs::BMSData_<ContainerAllocator2> & rhs)
{
  return lhs.pack_voltage == rhs.pack_voltage &&
    lhs.charge_current == rhs.charge_current &&
    lhs.discharge_current == rhs.discharge_current &&
    lhs.state_of_charge == rhs.state_of_charge &&
    lhs.remaining_time_to_full_charge == rhs.remaining_time_to_full_charge &&
    lhs.remaining_capacity == rhs.remaining_capacity &&
    lhs.state_of_health == rhs.state_of_health &&
    lhs.status_flags == rhs.status_flags &&
    lhs.temperature == rhs.temperature &&
    lhs.cell_voltage == rhs.cell_voltage &&
    lhs.cell_voltage_diff == rhs.cell_voltage_diff &&
    lhs.WST_serial == rhs.WST_serial &&
    lhs.bmz_flag == rhs.bmz_flag &&
    lhs.battery_type == rhs.battery_type &&
    lhs.full_voltage == rhs.full_voltage &&
    lhs.full_capacity == rhs.full_capacity &&
    lhs.temperature2 == rhs.temperature2 &&
    lhs.temperature_pcb == rhs.temperature_pcb &&
    lhs.cycle_count == rhs.cycle_count &&
    lhs.dsg_overcurrent_counter == rhs.dsg_overcurrent_counter &&
    lhs.chg_overcurrent_counter == rhs.chg_overcurrent_counter &&
    lhs.hw_major == rhs.hw_major &&
    lhs.hw_minor == rhs.hw_minor &&
    lhs.fw_major == rhs.fw_major &&
    lhs.fw_minor == rhs.fw_minor &&
    lhs.fw_patch == rhs.fw_patch &&
    lhs.fw_parameters_ok == rhs.fw_parameters_ok &&
    lhs.rec_fw_major == rhs.rec_fw_major &&
    lhs.rec_fw_minor == rhs.rec_fw_minor &&
    lhs.rec_fw_patch == rhs.rec_fw_patch &&
    lhs.bl_major == rhs.bl_major &&
    lhs.bl_minor == rhs.bl_minor &&
    lhs.status_enabled == rhs.status_enabled &&
    lhs.status_current_limitation == rhs.status_current_limitation &&
    lhs.status_switch_off_warn1 == rhs.status_switch_off_warn1 &&
    lhs.status_switch_off_warn2 == rhs.status_switch_off_warn2 &&
    lhs.status_fully_discharged == rhs.status_fully_discharged &&
    lhs.status_nearly_discharged == rhs.status_nearly_discharged &&
    lhs.status_chargefet_on == rhs.status_chargefet_on &&
    lhs.status_dischargefet_on == rhs.status_dischargefet_on &&
    lhs.status_discharging == rhs.status_discharging &&
    lhs.status_fully_charged == rhs.status_fully_charged &&
    lhs.status_charging == rhs.status_charging &&
    lhs.status_temp_charging_err == rhs.status_temp_charging_err &&
    lhs.status_cell_over_voltage == rhs.status_cell_over_voltage &&
    lhs.status_cell_under_voltage == rhs.status_cell_under_voltage &&
    lhs.status_charge_over_current == rhs.status_charge_over_current &&
    lhs.status_shortcircuit == rhs.status_shortcircuit &&
    lhs.status_discharge_over_current == rhs.status_discharge_over_current &&
    lhs.status_chargefet_voltage == rhs.status_chargefet_voltage &&
    lhs.status_dischargefet_voltage == rhs.status_dischargefet_voltage &&
    lhs.status_temp_discharging_err == rhs.status_temp_discharging_err &&
    lhs.status_charger_detected == rhs.status_charger_detected &&
    lhs.mnfct_bms_revision == rhs.mnfct_bms_revision &&
    lhs.mnfct_asn_revision == rhs.mnfct_asn_revision &&
    lhs.mnfct_year == rhs.mnfct_year &&
    lhs.mnfct_week == rhs.mnfct_week &&
    lhs.mnfct_model == rhs.mnfct_model &&
    lhs.mnfct_serial == rhs.mnfct_serial &&
    lhs.afe_i2c_error_count == rhs.afe_i2c_error_count &&
    lhs.app_error_count == rhs.app_error_count &&
    lhs.fet_disable_state == rhs.fet_disable_state &&
    lhs.last_battery_msg_time == rhs.last_battery_msg_time &&
    lhs.SBS_battery_status == rhs.SBS_battery_status &&
    lhs.SBS_battery_status_raw == rhs.SBS_battery_status_raw &&
    lhs.SBS_serial_1 == rhs.SBS_serial_1 &&
    lhs.SBS_serial_2 == rhs.SBS_serial_2 &&
    lhs.SBS_arti_nr_1 == rhs.SBS_arti_nr_1 &&
    lhs.SBS_arti_nr_2 == rhs.SBS_arti_nr_2 &&
    lhs.SBS_arti_nr_3 == rhs.SBS_arti_nr_3 &&
    lhs.SBS_curr_flow_passive_state == rhs.SBS_curr_flow_passive_state &&
    lhs.CHG_OC1_Count == rhs.CHG_OC1_Count &&
    lhs.CHG_OC2_Count == rhs.CHG_OC2_Count &&
    lhs.DSG_OC1_Count == rhs.DSG_OC1_Count &&
    lhs.DSG_OC2_Count == rhs.DSG_OC2_Count &&
    lhs.DSG_OC3_Count == rhs.DSG_OC3_Count &&
    lhs.AFE_OC1_Count == rhs.AFE_OC1_Count &&
    lhs.AFE_OC2_Count == rhs.AFE_OC2_Count &&
    lhs.CHG_LatchClear_Count == rhs.CHG_LatchClear_Count &&
    lhs.DSG_LatchClear_Count == rhs.DSG_LatchClear_Count &&
    lhs.chg_oc_warning == rhs.chg_oc_warning &&
    lhs.dsg_oc_warning == rhs.dsg_oc_warning;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::mir_msgs::BMSData_<ContainerAllocator1> & lhs, const ::mir_msgs::BMSData_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace mir_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::mir_msgs::BMSData_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::mir_msgs::BMSData_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::mir_msgs::BMSData_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::mir_msgs::BMSData_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::mir_msgs::BMSData_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::mir_msgs::BMSData_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::mir_msgs::BMSData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "64d9a6ee7004b0da6e7d451e7b57953b";
  }

  static const char* value(const ::mir_msgs::BMSData_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x64d9a6ee7004b0daULL;
  static const uint64_t static_value2 = 0x6e7d451e7b57953bULL;
};

template<class ContainerAllocator>
struct DataType< ::mir_msgs::BMSData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "mir_msgs/BMSData";
  }

  static const char* value(const ::mir_msgs::BMSData_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::mir_msgs::BMSData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float64 pack_voltage\n"
"float64 charge_current\n"
"float64 discharge_current\n"
"float64 state_of_charge\n"
"float64 remaining_time_to_full_charge\n"
"int32 remaining_capacity\n"
"int32 state_of_health\n"
"int32 DISCHARGING=1 #bit 0\n"
"int32 CHARGING=2    #bit 1\n"
"int32 OV=4         #bit 2 Over voltage\n"
"int32 UV=8          #bit 3 Under voltage\n"
"int32 COC=16         #bit 4 Charge over current\n"
"int32 DOC=32         #bit 5 Discharge over current\n"
"int32 DOT=64         #bit 6 Discharge over temperature\n"
"int32 DUT=128         #bit 7 Discharge under temperature\n"
"int32  SC=512         #bit 9\n"
"int32 COT=1024         #bit 10 Charge over temperature\n"
"int32 CUT=2048         #bit 11 Charge under temperature\n"
"int32 FW_STATUS_MSK=2031616 # to get Battery_Firmware_Status  do the following:\n"
"int32 FW_STATUS_SHIFT=16    # batt_fw_stat=(status_flags & FW_STATUS_MSK)>>FW_STATUS_SHIFT\n"
"int32 FW_UPD_OK=0                  #Battery firmware update finished OK.\n"
"int32 FW_UPD_RUNNING=1             #Battery firmware update running.\n"
"int32 FW_UPD_FAILED_BOOT=2         #Battery firmware update failed in Bootloader (Robot must not drive)\n"
"int32 FW_UPD_FAILED_APP=3          #Battery firmware update failed updating the application (Robot can drive with old FW)\n"
"int32 FW_UPD_FAILED_PARAM=4        #Battery firmware update failed uploading parameters (Robot can drive with old fw and parameters.)\n"
"int32 FW_STATUS_LOW_BATT=5         #Battery firmware update skipped battery too low or high (Robot can drive with old parameters.)\n"
"int32 FW_STATUS_FILE_CORRUPTED=6   #Battery firmware file corrupted (Robot can drive with old parameters.)\n"
"int32 FW_STATUS_CURRENT_TO_HIGH=7  #Battery firmware file corrupted (Robot can drive with old parameters.)\n"
"int32 FW_STATUS_NO_CAN=8           #Battery firmware update skipped no CAN communication (Robot can drive with old fw and parameters.)\n"
"int32 FW_BATTERY_IMBALANCE_HIGH=9  #Battery firmware update is enforced and the battery will be shut off by the new firmware\n"
"int32 status_flags\n"
"int32 temperature\n"
"uint32[] cell_voltage # In Mk2 robots and above the BMS provides data for 8 battery cells. 2Gen robots have BMS for 13 battery cells\n"
"uint32 cell_voltage_diff\n"
"\n"
"string WST_serial\n"
"\n"
"# Exteded diagnosticts for BMZ battery\n"
"uint32 bmz_flag # Flag for enabling extended diagnosticts\n"
"uint32 battery_type\n"
"uint32 BATT_TYPE_UNKNOWN=0      #type is unknown / no communucation\n"
"uint32 BATT_TYPE_BMZ=1          #BMZ battery\n"
"uint32 BATT_TYPE_WST=2          #WST battery\n"
"uint32 BATT_TYPE_SBS=3          #SBS battery\n"
"uint32 BATT_TYPE_SBS_SLIDE=4    #SBS SLIDE battery\n"
"uint32 BATT_TYPE_NO_BMS=255       #WST No BMS battery\n"
"float64 full_voltage\n"
"int32 full_capacity\n"
"int32 temperature2\n"
"int32 temperature_pcb\n"
"int32 cycle_count\n"
"int32 dsg_overcurrent_counter\n"
"int32 chg_overcurrent_counter\n"
"int32 hw_major\n"
"int32 hw_minor\n"
"int32 fw_major\n"
"int32 fw_minor\n"
"int32 fw_patch\n"
"int32 fw_parameters_ok\n"
"int32 rec_fw_major\n"
"int32 rec_fw_minor\n"
"int32 rec_fw_patch\n"
"int32 bl_major\n"
"int32 bl_minor\n"
"uint32 status_enabled\n"
"uint32 status_current_limitation\n"
"uint32 status_switch_off_warn1\n"
"uint32 status_switch_off_warn2\n"
"uint32 status_fully_discharged\n"
"uint32 status_nearly_discharged\n"
"uint32 status_chargefet_on\n"
"uint32 status_dischargefet_on\n"
"uint32 status_discharging\n"
"uint32 status_fully_charged\n"
"uint32 status_charging\n"
"uint32 status_temp_charging_err\n"
"uint32 status_cell_over_voltage\n"
"uint32 status_cell_under_voltage\n"
"uint32 status_charge_over_current\n"
"uint32 status_shortcircuit\n"
"uint32 status_discharge_over_current\n"
"float64 status_chargefet_voltage\n"
"float64 status_dischargefet_voltage\n"
"uint32 status_temp_discharging_err\n"
"uint32 status_charger_detected\n"
"uint32 mnfct_bms_revision\n"
"uint32 mnfct_asn_revision\n"
"uint32 mnfct_year\n"
"uint32 mnfct_week\n"
"uint32 mnfct_model\n"
"uint32 mnfct_serial\n"
"uint32 afe_i2c_error_count\n"
"uint32 app_error_count\n"
"uint32 fet_disable_state\n"
"\n"
"float64 last_battery_msg_time\n"
"\n"
"# SBS battery states\n"
"uint32 SBS_battery_status\n"
"uint32 SBS_battery_status_raw\n"
"uint32 SBS_InitState1=1\n"
"uint32 SBS_InitState2=2\n"
"uint32 SBS_InitState3=3\n"
"uint32 SBS_InitState4=4\n"
"uint32 SBS_Idle=5\n"
"uint32 SBS_Discharge=6\n"
"uint32 SBS_Charge=7\n"
"uint32 SBS_Fault=10\n"
"uint32 SBS_CriticalError=11\n"
"uint32 SBS_PrepareDeepsleep=99\n"
"uint32 SBS_Deepsleep=100\n"
"\n"
"string SBS_serial_1\n"
"string SBS_serial_2\n"
"\n"
"uint32 SBS_arti_nr_1\n"
"uint32 SBS_arti_nr_2\n"
"uint32 SBS_arti_nr_3\n"
"\n"
"uint32 SBS_curr_flow_passive_state\n"
"\n"
"# Overcurrent counters\n"
"uint8 CHG_OC1_Count\n"
"uint8 CHG_OC2_Count\n"
"uint8 DSG_OC1_Count\n"
"uint8 DSG_OC2_Count\n"
"uint8 DSG_OC3_Count\n"
"uint8 AFE_OC1_Count\n"
"uint8 AFE_OC2_Count\n"
"uint8 CHG_LatchClear_Count\n"
"uint8 DSG_LatchClear_Count\n"
"\n"
"uint8 chg_oc_warning\n"
"uint8 dsg_oc_warning\n"
;
  }

  static const char* value(const ::mir_msgs::BMSData_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::mir_msgs::BMSData_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.pack_voltage);
      stream.next(m.charge_current);
      stream.next(m.discharge_current);
      stream.next(m.state_of_charge);
      stream.next(m.remaining_time_to_full_charge);
      stream.next(m.remaining_capacity);
      stream.next(m.state_of_health);
      stream.next(m.status_flags);
      stream.next(m.temperature);
      stream.next(m.cell_voltage);
      stream.next(m.cell_voltage_diff);
      stream.next(m.WST_serial);
      stream.next(m.bmz_flag);
      stream.next(m.battery_type);
      stream.next(m.full_voltage);
      stream.next(m.full_capacity);
      stream.next(m.temperature2);
      stream.next(m.temperature_pcb);
      stream.next(m.cycle_count);
      stream.next(m.dsg_overcurrent_counter);
      stream.next(m.chg_overcurrent_counter);
      stream.next(m.hw_major);
      stream.next(m.hw_minor);
      stream.next(m.fw_major);
      stream.next(m.fw_minor);
      stream.next(m.fw_patch);
      stream.next(m.fw_parameters_ok);
      stream.next(m.rec_fw_major);
      stream.next(m.rec_fw_minor);
      stream.next(m.rec_fw_patch);
      stream.next(m.bl_major);
      stream.next(m.bl_minor);
      stream.next(m.status_enabled);
      stream.next(m.status_current_limitation);
      stream.next(m.status_switch_off_warn1);
      stream.next(m.status_switch_off_warn2);
      stream.next(m.status_fully_discharged);
      stream.next(m.status_nearly_discharged);
      stream.next(m.status_chargefet_on);
      stream.next(m.status_dischargefet_on);
      stream.next(m.status_discharging);
      stream.next(m.status_fully_charged);
      stream.next(m.status_charging);
      stream.next(m.status_temp_charging_err);
      stream.next(m.status_cell_over_voltage);
      stream.next(m.status_cell_under_voltage);
      stream.next(m.status_charge_over_current);
      stream.next(m.status_shortcircuit);
      stream.next(m.status_discharge_over_current);
      stream.next(m.status_chargefet_voltage);
      stream.next(m.status_dischargefet_voltage);
      stream.next(m.status_temp_discharging_err);
      stream.next(m.status_charger_detected);
      stream.next(m.mnfct_bms_revision);
      stream.next(m.mnfct_asn_revision);
      stream.next(m.mnfct_year);
      stream.next(m.mnfct_week);
      stream.next(m.mnfct_model);
      stream.next(m.mnfct_serial);
      stream.next(m.afe_i2c_error_count);
      stream.next(m.app_error_count);
      stream.next(m.fet_disable_state);
      stream.next(m.last_battery_msg_time);
      stream.next(m.SBS_battery_status);
      stream.next(m.SBS_battery_status_raw);
      stream.next(m.SBS_serial_1);
      stream.next(m.SBS_serial_2);
      stream.next(m.SBS_arti_nr_1);
      stream.next(m.SBS_arti_nr_2);
      stream.next(m.SBS_arti_nr_3);
      stream.next(m.SBS_curr_flow_passive_state);
      stream.next(m.CHG_OC1_Count);
      stream.next(m.CHG_OC2_Count);
      stream.next(m.DSG_OC1_Count);
      stream.next(m.DSG_OC2_Count);
      stream.next(m.DSG_OC3_Count);
      stream.next(m.AFE_OC1_Count);
      stream.next(m.AFE_OC2_Count);
      stream.next(m.CHG_LatchClear_Count);
      stream.next(m.DSG_LatchClear_Count);
      stream.next(m.chg_oc_warning);
      stream.next(m.dsg_oc_warning);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct BMSData_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::mir_msgs::BMSData_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::mir_msgs::BMSData_<ContainerAllocator>& v)
  {
    s << indent << "pack_voltage: ";
    Printer<double>::stream(s, indent + "  ", v.pack_voltage);
    s << indent << "charge_current: ";
    Printer<double>::stream(s, indent + "  ", v.charge_current);
    s << indent << "discharge_current: ";
    Printer<double>::stream(s, indent + "  ", v.discharge_current);
    s << indent << "state_of_charge: ";
    Printer<double>::stream(s, indent + "  ", v.state_of_charge);
    s << indent << "remaining_time_to_full_charge: ";
    Printer<double>::stream(s, indent + "  ", v.remaining_time_to_full_charge);
    s << indent << "remaining_capacity: ";
    Printer<int32_t>::stream(s, indent + "  ", v.remaining_capacity);
    s << indent << "state_of_health: ";
    Printer<int32_t>::stream(s, indent + "  ", v.state_of_health);
    s << indent << "status_flags: ";
    Printer<int32_t>::stream(s, indent + "  ", v.status_flags);
    s << indent << "temperature: ";
    Printer<int32_t>::stream(s, indent + "  ", v.temperature);
    s << indent << "cell_voltage[]" << std::endl;
    for (size_t i = 0; i < v.cell_voltage.size(); ++i)
    {
      s << indent << "  cell_voltage[" << i << "]: ";
      Printer<uint32_t>::stream(s, indent + "  ", v.cell_voltage[i]);
    }
    s << indent << "cell_voltage_diff: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.cell_voltage_diff);
    s << indent << "WST_serial: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.WST_serial);
    s << indent << "bmz_flag: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.bmz_flag);
    s << indent << "battery_type: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.battery_type);
    s << indent << "full_voltage: ";
    Printer<double>::stream(s, indent + "  ", v.full_voltage);
    s << indent << "full_capacity: ";
    Printer<int32_t>::stream(s, indent + "  ", v.full_capacity);
    s << indent << "temperature2: ";
    Printer<int32_t>::stream(s, indent + "  ", v.temperature2);
    s << indent << "temperature_pcb: ";
    Printer<int32_t>::stream(s, indent + "  ", v.temperature_pcb);
    s << indent << "cycle_count: ";
    Printer<int32_t>::stream(s, indent + "  ", v.cycle_count);
    s << indent << "dsg_overcurrent_counter: ";
    Printer<int32_t>::stream(s, indent + "  ", v.dsg_overcurrent_counter);
    s << indent << "chg_overcurrent_counter: ";
    Printer<int32_t>::stream(s, indent + "  ", v.chg_overcurrent_counter);
    s << indent << "hw_major: ";
    Printer<int32_t>::stream(s, indent + "  ", v.hw_major);
    s << indent << "hw_minor: ";
    Printer<int32_t>::stream(s, indent + "  ", v.hw_minor);
    s << indent << "fw_major: ";
    Printer<int32_t>::stream(s, indent + "  ", v.fw_major);
    s << indent << "fw_minor: ";
    Printer<int32_t>::stream(s, indent + "  ", v.fw_minor);
    s << indent << "fw_patch: ";
    Printer<int32_t>::stream(s, indent + "  ", v.fw_patch);
    s << indent << "fw_parameters_ok: ";
    Printer<int32_t>::stream(s, indent + "  ", v.fw_parameters_ok);
    s << indent << "rec_fw_major: ";
    Printer<int32_t>::stream(s, indent + "  ", v.rec_fw_major);
    s << indent << "rec_fw_minor: ";
    Printer<int32_t>::stream(s, indent + "  ", v.rec_fw_minor);
    s << indent << "rec_fw_patch: ";
    Printer<int32_t>::stream(s, indent + "  ", v.rec_fw_patch);
    s << indent << "bl_major: ";
    Printer<int32_t>::stream(s, indent + "  ", v.bl_major);
    s << indent << "bl_minor: ";
    Printer<int32_t>::stream(s, indent + "  ", v.bl_minor);
    s << indent << "status_enabled: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.status_enabled);
    s << indent << "status_current_limitation: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.status_current_limitation);
    s << indent << "status_switch_off_warn1: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.status_switch_off_warn1);
    s << indent << "status_switch_off_warn2: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.status_switch_off_warn2);
    s << indent << "status_fully_discharged: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.status_fully_discharged);
    s << indent << "status_nearly_discharged: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.status_nearly_discharged);
    s << indent << "status_chargefet_on: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.status_chargefet_on);
    s << indent << "status_dischargefet_on: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.status_dischargefet_on);
    s << indent << "status_discharging: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.status_discharging);
    s << indent << "status_fully_charged: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.status_fully_charged);
    s << indent << "status_charging: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.status_charging);
    s << indent << "status_temp_charging_err: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.status_temp_charging_err);
    s << indent << "status_cell_over_voltage: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.status_cell_over_voltage);
    s << indent << "status_cell_under_voltage: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.status_cell_under_voltage);
    s << indent << "status_charge_over_current: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.status_charge_over_current);
    s << indent << "status_shortcircuit: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.status_shortcircuit);
    s << indent << "status_discharge_over_current: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.status_discharge_over_current);
    s << indent << "status_chargefet_voltage: ";
    Printer<double>::stream(s, indent + "  ", v.status_chargefet_voltage);
    s << indent << "status_dischargefet_voltage: ";
    Printer<double>::stream(s, indent + "  ", v.status_dischargefet_voltage);
    s << indent << "status_temp_discharging_err: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.status_temp_discharging_err);
    s << indent << "status_charger_detected: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.status_charger_detected);
    s << indent << "mnfct_bms_revision: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.mnfct_bms_revision);
    s << indent << "mnfct_asn_revision: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.mnfct_asn_revision);
    s << indent << "mnfct_year: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.mnfct_year);
    s << indent << "mnfct_week: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.mnfct_week);
    s << indent << "mnfct_model: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.mnfct_model);
    s << indent << "mnfct_serial: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.mnfct_serial);
    s << indent << "afe_i2c_error_count: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.afe_i2c_error_count);
    s << indent << "app_error_count: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.app_error_count);
    s << indent << "fet_disable_state: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.fet_disable_state);
    s << indent << "last_battery_msg_time: ";
    Printer<double>::stream(s, indent + "  ", v.last_battery_msg_time);
    s << indent << "SBS_battery_status: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.SBS_battery_status);
    s << indent << "SBS_battery_status_raw: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.SBS_battery_status_raw);
    s << indent << "SBS_serial_1: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.SBS_serial_1);
    s << indent << "SBS_serial_2: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.SBS_serial_2);
    s << indent << "SBS_arti_nr_1: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.SBS_arti_nr_1);
    s << indent << "SBS_arti_nr_2: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.SBS_arti_nr_2);
    s << indent << "SBS_arti_nr_3: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.SBS_arti_nr_3);
    s << indent << "SBS_curr_flow_passive_state: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.SBS_curr_flow_passive_state);
    s << indent << "CHG_OC1_Count: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.CHG_OC1_Count);
    s << indent << "CHG_OC2_Count: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.CHG_OC2_Count);
    s << indent << "DSG_OC1_Count: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.DSG_OC1_Count);
    s << indent << "DSG_OC2_Count: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.DSG_OC2_Count);
    s << indent << "DSG_OC3_Count: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.DSG_OC3_Count);
    s << indent << "AFE_OC1_Count: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.AFE_OC1_Count);
    s << indent << "AFE_OC2_Count: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.AFE_OC2_Count);
    s << indent << "CHG_LatchClear_Count: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.CHG_LatchClear_Count);
    s << indent << "DSG_LatchClear_Count: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.DSG_LatchClear_Count);
    s << indent << "chg_oc_warning: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.chg_oc_warning);
    s << indent << "dsg_oc_warning: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.dsg_oc_warning);
  }
};

} // namespace message_operations
} // namespace ros

#endif // MIR_MSGS_MESSAGE_BMSDATA_H
